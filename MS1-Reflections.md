# MS1 Reflections

Initially, I attempted to perform the static semantic analysis by writing a program that converted my AST traversal into JSON format, hoping to be able to parse this JSON. However, I soon realized that this wouldn't exactly work, since a lot of the analysis relies upon the order in which certain pieces of the code are declared/executed (for example, when it comes to validating the use of variables by checking local and global scopes). After that, I attempted to make a separate python program specifically for the static semantic analysis, separate from the AST visitor. This was working pretty well, but then I spoke to Dr. Sturton and realized that my compiler should be doing the semantic analysis in a single traversal of the AST. I then had to migrate the logic I'd implemented and incorporate it into my original pretty_print_visitor.py program. 

I didn't make any modifications to the AST traversal itself, but I added several helper functions to my program, and I also added semantic analysis error-checking at the beginning of many of the `visit()` methods (always before the calls to `.accept(self)`). 

I added a simple helper function for printing out errors and keeping track of the total number of errors via a class field. Most of the helper functions I added to my program had to do with type checking (honestly, I felt like the majority of semantic analysis/error checking I was implementing all came down to type checking). 

One of the major functions I implemented was a helper function `type_of_expr(self,e:expression_ast.Expression)`, which deduces which type of expression was passed in (using `isinstance()`),  and then contains logic for deducing and returning the 'type' that the expression evaluates to. Since I had to account for each expression type--invocation expressions, binary expressions, etc.--a good portion of the semantic analysis logic, error checking, and error reporting ended up being inside of this function. I then used this helper function in much of the checking done inside the `visit()` functions (For example: checking whether the return type matched the function signature, checking whether two sides of an assignment statement evaluated to the same type, etc.). Several other helper functions were implemented for evaluating the type of `lvalue`s and dot fields.

To set up my symbol tables and manage scoping, I declared 4 global dictionaries to keep track of struct declarations, functions, global variables, and the variables local to each scope--at the end of the traversal, I had helper functions which converted these dictionaries into pretty-printed symbol tables. Populating the struct, function, and global variable tables was easy--I had helper 'collection' functions that I called at the beginning of `visit_program()`. When it came to scoping, I handled this by adding an entry to this dictionary (called `self.vars`) whenever `visit_function()` was called, at the beginning of that method. Additionally, at the top of `visit_function()`, I set the value of a global `self.current_fun` variable to be the name of the current function, so that later references to variables could be checked against the correct, current scope.
